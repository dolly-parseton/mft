use byteorder::{LittleEndian, ReadBytesExt};
use std::io::{Read, Seek, SeekFrom};

#[derive(Debug)]
pub struct AttributeList(pub Vec<AttributeListItem>);

#[derive(Debug)]
pub struct AttributeListItem {
    pub attribute_type: u32,
    pub record_length: u16,
    pub name_length: u8,
    pub name_offset: u8,
    pub lowest_vnc: u64,
    pub file_reference: crate::raw::FileReference,
    pub attribute_id: u16,
    //
    pub name: String,
}

impl AttributeList {
    pub fn from_reader<R: Read + Seek>(reader: &mut R, attribute_size: u64) -> crate::Result<Self> {
        let mut attributes = Vec::new();
        let starting_offset = reader.seek(SeekFrom::Current(0))?;
        //
        loop {
            let current_offset = reader.seek(SeekFrom::Current(0))?;
            let attribute = AttributeListItem::from_reader(reader)?;
            //
            if attribute.record_length == 0 {
                break;
            }
            if current_offset + attribute.record_length as u64 >= starting_offset + attribute_size {
                attributes.push(attribute);
                break;
            } else {
                reader.seek(SeekFrom::Start(
                    current_offset + attribute.record_length as u64,
                ))?;
            }
            //
            attributes.push(attribute);
        }
        Ok(Self(attributes))
    }

    pub fn resolve_to_blocks(
        &self,
        blocks: &[crate::block::Block],
    ) -> Vec<(u64, crate::block::BlockInner)> {
        let mut targets = Vec::new();
        // For each attribute list item match to entry by file reference and attribute id
        for attribute_item in &self.0 {
            let block = blocks
                .iter()
                .find(|b| b.entry_id == attribute_item.file_reference.entry);
            if let Some(block) = block {
                let inner = block.blocks.iter().find(|b| {
                    if let Some(id) = b.attribute_id {
                        id == attribute_item.attribute_id
                    } else {
                        false
                    }
                });
                if let Some(inner) = inner {
                    targets.push((block.entry_id, inner.clone()));
                } else {
                    unimplemented!() // TODO: Handle this case
                }
            } else {
                unimplemented!() // bad could not find block
            }
        }
        targets
    }
}

impl AttributeListItem {
    pub fn from_reader<R: Read + Seek>(reader: &mut R) -> crate::Result<Self> {
        let start_of_attribute_offset = reader.seek(SeekFrom::Current(0))?;
        read_value!(reader, attribute_type, read_u32);
        read_value!(reader, record_length, read_u16);
        let name_length = reader
            .read_u8()
            .map_err(|e| crate::Error::into_value_read_error(e.into(), "name_length", "read_u8"))?;
        let name_offset = reader
            .read_u8()
            .map_err(|e| crate::Error::into_value_read_error(e.into(), "name_offset", "read_u8"))?;
        read_value!(reader, lowest_vnc, read_u64);
        read_value!(reader, file_reference, read_u64);
        read_value!(reader, attribute_id, read_u16);
        //
        let mut name = String::new();
        let prev_offset = reader.seek(SeekFrom::Current(0))?;
        reader.seek(SeekFrom::Start(
            start_of_attribute_offset + name_offset as u64,
        ))?;
        for _ in 0..name_length {
            let c = reader.read_u16::<LittleEndian>().map_err(|e| {
                crate::Error::into_value_read_error(e.into(), "name_char", "read_u16")
            })?;
            name.push(c as u8 as char);
        }
        reader.seek(SeekFrom::Start(prev_offset))?;
        //
        Ok(Self {
            attribute_type,
            record_length,
            name_length,
            name_offset,
            lowest_vnc,
            file_reference: crate::raw::FileReference::from(file_reference),
            attribute_id,
            name,
        })
    }
}

#[cfg(test)]
mod tests {
    use crate::MftParser;
    use std::io::Cursor;
    use std::path::PathBuf;
    use std::str::FromStr;

    use super::*;
    #[test]
    fn attribute_list_test() {
        let data: Vec<u8> = vec![
            0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x43,
            0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x1a, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x20, 0x00,
            0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x31, 0x01, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0d, 0x31, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x24, 0x00, 0x49, 0x00,
            0x33, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x31,
            0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x24, 0x00, 0x44, 0x00, 0x53, 0x00,
            0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x30, 0x00,
            0x09, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x24, 0x00, 0x54, 0x00, 0x58, 0x00, 0x46, 0x00,
            0x5f, 0x00, 0x44, 0x00, 0x41, 0x00, 0x54, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let size = data.len() as u64;
        println!("size: {}", size);
        let mut reader = Cursor::new(data);
        let attribute_list = AttributeList::from_reader(&mut reader, size).unwrap();
        println!("{:?}", attribute_list);
    }

    #[test]
    fn resolution_test() {
        let data: Vec<u8> = vec![
            0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x43,
            0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x1a, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x20, 0x00,
            0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x31, 0x01, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0d, 0x31, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x24, 0x00, 0x49, 0x00,
            0x33, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x28, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x31,
            0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00, 0x24, 0x00, 0x44, 0x00, 0x53, 0x00,
            0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x30, 0x00,
            0x09, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb2, 0xb3, 0x01, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x24, 0x00, 0x54, 0x00, 0x58, 0x00, 0x46, 0x00,
            0x5f, 0x00, 0x44, 0x00, 0x41, 0x00, 0x54, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let size = data.len() as u64;
        let mut reader = Cursor::new(data);
        let attribute_list = AttributeList::from_reader(&mut reader, size).unwrap();
        //
        let path = PathBuf::from_str("./.test_data/mft.mft").unwrap();
        println!("{:#?}", path);
        let mut parser = MftParser::from_path(path).unwrap();

        let resolved = attribute_list.resolve_to_blocks(&parser.blocks);
        println!("{:#?}", resolved);
    }
}

// 0x1310d
